CREATE TABLE TEST(		ID VARCHAR2(4000),	
		PW CHAR(10),	
		NUM NUMBER(38),        	
		NUM2 NUMBER(4,2),	
		FLOATING_POINT NUMBER,	
		CONTENTS CLOB,	
		WRITE_DATE DATE      );	
CREATE TABLE DEPT_T AS SELECT * FROM DEPT;			
CREATE TABLE DEPT_T AS SELECT * FROM DEPT WHERE 1!=1;			
DESC 확인 할 테이블명 ;			ex.
ALTER TABLE TEST ADD XXX NUMBER(3);			
ALTER TABLE TEST RENAME COLUMN XXX TO YYY;			
ALTER TABLE TEST MODIFY YYY NUMBER(5);			
ALTER TABLE TEST DROP COLUMN YYY;			
RENAME TEST TO TEST2;			
DROP TABLE TEST;			
INSERT INTO TEST VALUES( '4', 'a', '가', 10 );			
INSERT INTO TEST (ID) VALUES('1');		INSERT INTO TEST (ID,NAME) VALUES('3','개');	
INSERT INTO EMP_T (HIREDATE) VALUES ( '2021/09/06' ); -- 연월일은 넣고 시분초는 0으로 들어감			
INSERT INTO EMP_T (HIREDATE) VALUES (SYSDATE); -- 현재 시간 입력			
SELECT * FROM TEST;			
SELECT NO,TITLE,WID,TO_CHAR(DATE_W,'YYYY/MM/DD HH24:MI:SS') FROM BF ORDER BY TITLE ASC, DATE_W DESC;	
1차로 TITLE 을 기준으로 정렬하고, 그렇게 정렬된 상태에서 2차로 DATE_W 로 정렬함.	
	SELECT TO_CHAR(DATE_W,'YYYY/MM/DD HH24:MI:SS') FROM BF;
SELECT * FROM TEST WHERE ID >= 1;	
SELECT * FROM TEST WHERE NUM IS NOT NULL;	
SELECT * FROM TEST WHERE NUM IS NULL;	
ex.	번호가 6이상이면서 이름에 '손' 이 들어간 선수들만 출력
UPDATE TEST SET NUM = 5 WHERE ID = 3;	
UPDATE TEST SET NUM = 5;	
DELETE TEST WHERE ID = 6;	
DELETE FROM MEMBER;	
TRUNCATE TABLE TEST; 	
	대상열 자료형 constraint 제약조건이름 제약조건내용 
CREATE TABLE TEST( ID VARCHAR2(4000) NOT NULL );	
CREATE TABLE TEST( ID VARCHAR2(4000) UNIQUE );	
CREATE TABLE TEST( ID VARCHAR2(4000) PRIMARY KEY );	
이건 제약조건 이름 주세요(혹시 모를 제약 조건 삭제를 위해)	
CREATE TABLE MEMBER( NO NUMBER(1), ID VARCHAR2(4000) DEFAULT '고양이' );	
이렇게 부분 칼럼만 값을 넣고..	
셀렉트 해보면..	
로 나옴	1
	
CREATE TABLE MEMBER( ID VARCHAR2(4000) UNIQUE );	
INSERT INTO MEMBER VALUES('NYANG4');	
CREATE TABLE TEST( ID VARCHAR2(4000) REFERENCES MEMBER(ID) );	
INSERT INTO TEST VALUES('NYANG4');	
INSERT INTO TEST VALUES('NYANG6'); --에러: ORA-02291: 무결성 제약조건(SCOTT.SYS_C0011358)이 위배되었습니다- 부모 키가 없습니다	

SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME='테이블명';
ALTER TABLE TEST MODIFY NO NUMBER(36) NOT NULL;
ALTER TABLE TEST MODIFY NO NUMBER(36) UNIQUE;
ALTER TABLE TEST MODIFY NO NUMBER(36) PRIMARY KEY;
ALTER TABLE TEST MODIFY NO CONSTRAINT TEST_CR_CK CHECK(NO>0);
ALTER TABLE TEST MODIFY( NO CONSTRAINT TEST_CR_CK CHECK(NO>0) );
ALTER TABLE TEST MODIFY NO NUMBER(36) CONSTRAINT TEST_CR_CK CHECK(NO>0);
ALTER TABLE TEST MODIFY NO( NUMBER(36) CONSTRAINT TEST_CR_CK CHECK(NO>0) );
ALTER TABLE TEST MODIFY NO NUMBER(36) DEFAULT 0;
ALTER TABLE 선수단 MODIFY POSITION REFERENCES POSITION_TYPE(POSITION);
ALTER TABLE TEST MODIFY ID VARCHAR2(4000) NULL;
ALTER TABLE TEST DROP UNIQUE(ID);
ALTER TABLE TEST DROP PRIMARY KEY;
ALTER TABLE TEST DROP CONSTRAINT TEST_CR_CK;
ALTER TABLE TEST MODIFY NO NUMBER(36) DEFAULT NULL;
SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME='해당테이블명';
ALTER TABLE CT DROP CONSTRAINT SYS_C0011379;
CREATE TABLE T1( NO NUMBER(1) );
INSERT INTO T1 VALUES(1);
INSERT INTO T1 VALUES(2);
CREATE TABLE T2( NO NUMBER(1), ID CHAR(1) );
INSERT INTO T2 VALUES(1,'A');
INSERT INTO T2 VALUES(2,'B');
INSERT INTO T2 VALUES(3,'C');
SELECT * FROM T1,T2;
SELECT * FROM T1,T2 WHERE T1.NO = T2.NO;
SELECT no,id FROM T1,T2 WHERE T1.NO = T2.NO; -- 에러. 이유: no 열이 어떤 테이블의 열인지 모르기때문(t1에도 no열이 있고, t2에도 no열이 있어서)
SELECT t1.no,t2.id FROM T1,T2 WHERE T1.NO = T2.NO; -- 열 이름이 겹치는 경우 테이블명.열이름 으로 표시해야함.

CREATE TABLE T( TYPE CHAR(9), VAL CHAR(9) );
INSERT INTO T VALUES('포유류','개');
INSERT INTO T VALUES('포유류','고양이');
INSERT INTO T VALUES('포유류','너굴맨');
INSERT INTO T VALUES('어류','광어');
INSERT INTO T VALUES('어류','상어');
SELECT * FROM T;
SELECT COUNT(*) FROM T;
SELECT COUNT(*) FROM T WHERE TYPE = '어류';
SELECT COUNT(*) FROM T WHERE TYPE = '포유류';
SELECT COUNT(*) FROM T GROUP BY TYPE;
SELECT TYPE, COUNT(*) FROM T GROUP BY TYPE;

SELECT TYPE, COUNT(*) FROM T GROUP BY TYPE HAVING TYPE='포유류';
"CREATE TABLE T1( NO NUMBER(1), animal varchar2(20) );		"
"INSERT INTO T1 VALUES(1,'개');		"
INSERT INTO T1 VALUES(2,'고양이');                
CREATE TABLE T2( NO NUMBER(1) );
INSERT INTO T2 VALUES(1);
INSERT INTO T2 VALUES(2);
SELECT * FROM T1;
SELECT COUNT(*) FROM T2;
SELECT * FROM T1 WHERE NO = (SELECT COUNT(*) FROM T2);
SELECT * FROM T1 WHERE NO = 2;




SELECT * FROM T1 WHERE NO <= (SELECT COUNT(*) FROM T2);
SELECT * FROM T1 WHERE NO <= 2;
DROP TABLE T1;
DROP TABLE T2;

commit;